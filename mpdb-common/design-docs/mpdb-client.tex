\documentclass[10pt,letterpaper,onecolumn,oneside]{report}
\begin{document}
\title{mpdb-client}
\author{Anthony Waters}
\date{February 2, 2008}
\maketitle
\tableofcontents
\newpage
\part{Introduction}
The part of the project mpdb-client is responsible for creating, display, and updating the user interface of the application.  All of the source code within this project is converted to JavaScript through the use of Google Web Toolkit (GWT).
\chapter{Bulk Upload}
Bulk upload is the process in which a document in a preset format is parsed for data, basically a scientists adds a lot of samples to a spreadsheet and then the application parses the spreadsheet to add samples.  This is beneficial because it allows the scientists to circumvent the process of adding the samples individually by hand.  The process of performing a bulk upload can be summarized into four steps3
\begin{enumerate}
\item Uploading the document
\item Parsing the document
\item Saving the objects in the database
\item Reporting the status of the operation (success/failure)
\end{enumerate}
\section{Uploading the Document}
In order to transfer documents from the client to the server a file upload needs to occur.  This is accomplished with a GWT widget named a
\texttt{FormPanel}, this allows for sending POST request to the server.  Another situation that this is used in is in upload images to the server.  A very simple interface for testing bulk upload is located in the package 
\texttt{edu\ .rpi\ .metpetdb\ .client\ .ui\ .bulk\ .upload} the name of the class is
\texttt{BulkUploadPanel}.  If you look at it you will notice how simple it is, just a file upload control.  The interesting thing to note here though is where the \texttt{FormPanel} posts to, which is \texttt{fp.setAction(GWT.getModuleBaseURL() + "/bulkUpload");}.  What this means is it post to the bulkUpload servlet on the server, which brings us to the next section.
\section{Parsing the Document}
The post request is sent to the bulkUpload servlet which is located in the package \texttt{edu\ .rpi\ .metpetdb\ .server} within the class \texttt{BulkUploadServlet}. 
 This is a simple servlet whos only function is to save the file on the server, and then based on the type of bulk upload it passes the file onto the parsers located in the package \texttt{edu\ .rpi\ .metpetdb\ .server\ .bulk\ .upload}.  Parsing the files is a fairly simple task because there is a library already available from Apache called POI, which stands for ``Poor Obfuscation Implementation''.  The part of the libary that is used for handling the spreadsheets is called HSSF, which stands for ``Horrible SpreadSheet Format'' (it is refering to Microsoft Excel in this case).  A simple tutorial on how to use POI and in particular HSSF is located at http://poi.apache.org/hssf/how-to.html.  An example is also located in the source file \texttt{SampleParser.java} in the package \texttt{edu.rpi.metpetdb.server.bulk.upload.sample}.  It works exactly like going through a table, you go row by row and column by column.  So in order to parse the spreadsheet one would first read the first row, which contains the column headers, then subsequently read every other row parsing the data and determining what it is based on it's column header.  How to actually save that data is discussed in the next section.
\section{Saving the objects in the database}
In order to explain this section I will use a Sample object as an example, therefore the user uploaded a spreadsheet that contains just samples. 
 The java bean for the sample is located in the class \texttt{Sample} in the package \texttt{edu\ .rpi\ .metpetdb\ .client\ .model} this contains all of the properties for a sample that are read and written by the database.  With that in mind in order to save the data to the database the following has to happen
\begin{enumerate}
\item Create a new sample object
\begin{itemize}
\item \texttt{final Sample s = new Sample()}
\end{itemize}
\item Set the properties of the sample based on the data
\begin{itemize}
\item \texttt{s.setAlias(``My Lovely Sample'');}
\end{itemize}
\item Save the sample to the database
\begin{itemize}
\item \texttt{saveSample(s)}, located in \texttt{SampleServiceImpl}
\end{itemize}
\end{enumerate}
The next step is to notify the user of the result of the operation.
\section{Reporting the status of the operation (success/failure)}
To send back a message to the client about the status of the operation you could do the following
\begin{enumerate}
\item If there was an error
\begin{itemize}
\item throw an exception that will get passed to the client
\item \texttt{throw new InvalidFormatException}
\item the exception will contain the necessary details to will be displayed to the client about what caused the error
\end{itemize}
\item If it was successful
\begin{itemize}
\item Return a string telling the user that is was successful
\item Add in things like what was added and links to them
\end{itemize}
\end{enumerate}
\chapter{Adding/Editing Objects}
Adding and editing objects forms the basis of the database therefore their functionality
is vert important.  The type of objects that can be edited include
\begin{itemize}
\item Grids (Subsample Maps)
\item Images
\item Mineral Analyses
\item Projects
\item Sample
\item Subsample
\end{itemize}
As a basis for describing the procedure of how adding and editing objects occurs I will use
a Sample because it represents the most complex object to date.
\section{Adding Objects}
The start of the interface for adding Samples is located in the class \texttt{SampleDetails}
that is within the package \texttt{edu\ .rpi\ .metpetdb\ .client\ .objects\ .details}. 
Within this class there are a couple things that are unique to this class
\begin{enumerate}
\item \texttt{private static GenericAttribute[] sampleAtts}
\item \texttt{private final ObjectEditorPanel p\_sample}
\end{enumerate}
Basically the way it works is all of the \texttt{sampleAtts} are layed
out on the \texttt{p\_sample} widget.
\subsection{What are these GenericAttributes?}
The \texttt{GenericAttribute}s are composed of two things
\begin{enumerate}
\item the attribute itself, i.e. \texttt{TextAttribute}
\item the constraint, i.e. \texttt{MpDb.doc.Sample\_alias}
\end{enumerate}
\subsection{The Attributes}
The attributes is the actually GWT Widget that is placed in the DOM and
rendered to the browser, therefore, if you need to change something UI
related it is in the attributes.  If you look at the
\texttt{edu\ .rpi\ .metpetdb\ .client\ .ui\ .input\ .attributes} package
you will notice that there are regular attributes in the parent package
and attributes that are in the \texttt{specific} package.  Attributes
that are in the regular package are very generic, meaning that they can
be used in any object along as the constraint is correct.
A good example of a regular attribute is the \texttt{TextAttribute}.  
The primary purpose of the text attribute is to allow for single line
free text to be entered, as you have guessed, this functionality is
required in many of the objects.  As opposed to regular attributes, the
specific attributes are very specific in functionality and are
very hard to abstract.  A good example of a specific attribute would
be the \texttt{MineralAttribute}, whose prime purpose is to allow
the user to select various amounts of minerals from a tree.  The beauty
of this specific attribute is the fact that it makes use of a regular
attribute, the \texttt{TreeAttribute}.  In describing the attribute I
will refer to the \texttt{TextAttribute} as the example.
\subsubsection{Creating an Attribute}
First off attributes are \textbf{required} to extend a \texttt{GenericAttribute}
, along with extending that class a few methods need to be implemented
\begin{itemize}
\item constructor that calls \texttt{protected GenericAttribute(final PropertyConstraint pc}
\begin{itemize}
\item This is necessary because it initializes the \texttt{GenericAttribute}
with things like the label (which is displayed to the left of the attribute).  An example of a label would be ''Sesar Number''
\end{itemize}
\item \texttt{public abstract Widget[] createDisplayWidget(MObjectDTO obj)}
\begin{itemize}
\item Whatever that is returned here will be added to the DOM when an object
is being viewed.  For example with the \texttt{TextAttribute} this method
returns just a \texttt{Label} because it is used to show data.  The reason
that this methods returns an array of \texttt{Widget}s is because for each
widget in the array a new row in the display table will be added.
\end{itemize}
\item \texttt{public abtract void set(final MObjectDTO obj, final Object value)}
\begin{itemize}
\item When the user clicks Save the new object is passed in as the first
parameter, and then the value for that object is passed in as the second
parameter.  Usually this method just calls \texttt{mSet} which sets the value
in the object itself.  For more understanding look at the \texttt{mSetGet}
method of any of the Java Beans, i.e. \texttt{Sample}.
\end{itemize}
\end{itemize}
while the following methods are generally implemented as well
\begin{itemize}
\item \texttt{public Widget[] createEditWidget(final MObjectDTO obj, final String id)}
\begin{itemize}
\item TODO
\end{itemize}
\item \texttt{protected Object get(final Widget editWidget)}
\begin{itemize}
\item TODO
\end{itemize}
\end{itemize}
More advanced attributes have more methods, for example the \texttt{TreeAttribute}.

\subsubsection{Simplified Flow of an Attribute}
\subsection{The Constraints}
\end{document}
