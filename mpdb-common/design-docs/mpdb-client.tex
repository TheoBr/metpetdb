\documentclass[10pt,letterpaper,onecolumn,oneside]{report}
\begin{document}
\title{mpdb-client}
\author{Anthony Waters}
\maketitle
\tableofcontents
\newpage
\part{Introduction}
The part of the project mpdb-client is responsible for creating, display, and updating the user interface of the application.  All of the source code within this project is converted to JavaScript through the use of Google Web Toolkit (GWT).
\chapter{Bulk Upload}
Bulk upload is the process in which a document in a preset format is parsed for data, basically a scientists adds a lot of samples to a spreadsheet and then the application parses the spreadsheet to add samples.  This is beneficial because it allows the scientists to circumvent the process of adding the samples individually by hand.  The process of performing a bulk upload can be summarized into four steps3
\begin{enumerate}
\item Uploading the document
\item Parsing the document
\item Saving the objects in the database
\item Reporting the status of the operation (success/failure)
\end{enumerate}
\section{Uploading the Document}
In order to transfer documents from the client to the server a file upload needs to occur.  This is accomplished with a GWT widget named a
\texttt{FormPanel}, this allows for sending POST request to the server.  Another situation that this is used in is in upload images to the server.  A very simple interface for testing bulk upload is located in the package 
\texttt{edu\ .rpi\ .metpetdb\ .client\ .ui\ .bulk\ .upload} the name of the class is
\texttt{BulkUploadPanel}.  If you look at it you will notice how simple it is, just a file upload control.  The interesting thing to note here though is where the \texttt{FormPanel} posts to, which is \texttt{fp.setAction(GWT.getModuleBaseURL() + "/bulkUpload");}.  What this means is it post to the bulkUpload servlet on the server, which brings us to the next section.
\section{Parsing the Document}
The post request is sent to the bulkUpload servlet which is located in the package \texttt{edu\ .rpi\ .metpetdb\ .server} within the class \texttt{BulkUploadServlet}. 
 This is a simple servlet whos only function is to save the file on the server, and then based on the type of bulk upload it passes the file onto the parsers located in the package \texttt{edu\ .rpi\ .metpetdb\ .server\ .bulk\ .upload}.  Parsing the files is a fairly simple task because there is a library already available from Apache called POI, which stands for ``Poor Obfuscation Implementation''.  The part of the libary that is used for handling the spreadsheets is called HSSF, which stands for ``Horrible SpreadSheet Format'' (it is refering to Microsoft Excel in this case).  A simple tutorial on how to use POI and in particular HSSF is located at http://poi.apache.org/hssf/how-to.html.  An example is also located in the source file \texttt{SampleParser.java} in the package \texttt{edu.rpi.metpetdb.server.bulk.upload.sample}.  It works exactly like going through a table, you go row by row and column by column.  So in order to parse the spreadsheet one would first read the first row, which contains the column headers, then subsequently read every other row parsing the data and determining what it is based on it's column header.  How to actually save that data is discussed in the next section.
\section{Saving the objects in the database}
In order to explain this section I will use a Sample object as an example, therefore the user uploaded a spreadsheet that contains just samples. 
 The java bean for the sample is located in the class \texttt{Sample} in the package \texttt{edu\ .rpi\ .metpetdb\ .client\ .model} this contains all of the properties for a sample that are read and written by the database.  With that in mind in order to save the data to the database the following has to happen
\begin{enumerate}
\item Create a new sample object
\begin{itemize}
\item \texttt{final Sample s = new Sample()}
\end{itemize}
\item Set the properties of the sample based on the data
\begin{itemize}
\item \texttt{s.setAlias(``My Lovely Sample'');}
\end{itemize}
\item Save the sample to the database
\begin{itemize}
\item \texttt{saveSample(s)}, located in \texttt{SampleServiceImpl}
\end{itemize}
\end{enumerate}
The next step is to notify the user of the result of the operation.
\section{Reporting the status of the operation (success/failure)}
To send back a message to the client about the status of the operation you could do the following
\begin{enumerate}
\item If there was an error
\begin{itemize}
\item throw an exception that will get passed to the client
\item \texttt{throw new InvalidFormatException}
\item the exception will contain the necessary details to will be displayed to the client about what caused the error
\end{itemize}
\item If it was successful
\begin{itemize}
\item Return a string telling the user that is was successful
\item Add in things like what was added and links to them
\end{itemize}
\end{enumerate}
\chapter{Adding/Editing Objects}
Adding and editing objects forms the basis of the database therefore their functionality
is vert important.  The type of objects that can be edited include
\begin{itemize}
\item Grids (Subsample Maps)
\item Images
\item Mineral Analyses
\item Projects
\item Sample
\item Subsample
\end{itemize}
As a basis for describing the procedure of how adding and editing objects occurs I will use
a Sample because it represents the most complex object to date.
\section{Adding Objects}
The start of the interface for adding Samples is located in the class \texttt{SampleDetails}
that is within the package \texttt{edu\ .rpi\ .metpetdb\ .client\ .objects\ .details}. 
Within this class there are a couple things that are unique to this class
\begin{enumerate}
\item \texttt{private static GenericAttribute[] sampleAtts}
\item \texttt{private final ObjectEditorPanel p\_sample}
\end{enumerate}
Basically the way it works is all of the \texttt{sampleAtts} are layed
out on the \texttt{p\_sample} widget.
\subsection{What are these GenericAttributes?}
The \texttt{GenericAttribute}s are composed of two things
\begin{enumerate}
\item the attribute itself, i.e. \texttt{TextAttribute}
\item the constraint, i.e. \texttt{MpDb.doc.Sample\_alias}
\end{enumerate}
\subsection{The Attributes}
The attributes is the actually GWT Widget that is placed in the DOM and
rendered to the browser, therefore, if you need to change something UI
related it is in the attributes.  If you look at the
\texttt{edu\ .rpi\ .metpetdb\ .client\ .ui\ .input\ .attributes} package
you will notice that there are regular attributes in the parent package
and attributes that are in the \texttt{specific} package.  Attributes
that are in the regular package are very generic, meaning that they can
be used in any object along as the constraint is correct.
A good example of a regular attribute is the \texttt{TextAttribute}.  
The primary purpose of the text attribute is to allow for single line
free text to be entered, as you have guessed, this functionality is
required in many of the objects.  As opposed to regular attributes, the
specific attributes are very specific in functionality and are
very hard to abstract.  A good example of a specific attribute would
be the \texttt{MineralAttribute}, whose prime purpose is to allow
the user to select various amounts of minerals from a tree.  The beauty
of this specific attribute is the fact that it makes use of a regular
attribute, the \texttt{TreeAttribute}.  In describing the attribute I
will refer to the \texttt{TextAttribute} as the example.
\subsubsection{Creating an Attribute}
First off attributes are \textbf{required} to extend a \texttt{GenericAttribute}
, along with extending that class a few methods need to be implemented
\begin{itemize}
\item constructor that calls \texttt{protected GenericAttribute(final PropertyConstraint pc}
\begin{itemize}
\item This is necessary because it initializes the \texttt{GenericAttribute}
with things like the label (which is displayed to the left of the attribute).  An example of a label would be ``Sesar Number''
\end{itemize}
\item \texttt{public abstract Widget[] createDisplayWidget(MObjectDTO obj)}
\begin{itemize}
\item Whatever that is returned here will be added to the DOM when an object
is being viewed.  For example with the \texttt{TextAttribute} this method
returns just a \texttt{Label} because it is used to show data.  The reason
that this methods returns an array of \texttt{Widget}s is because for each
widget in the array a new row in the display table will be added.
\end{itemize}
\item \texttt{public abtract void set(final MObjectDTO obj, final Object value)}
\begin{itemize}
\item When the user clicks Save the new object is passed in as the first
parameter, and then the value for that object is passed in as the second
parameter.  Usually this method just calls \texttt{mSet} which sets the value
in the object itself.  For more understanding look at the \texttt{mSetGet}
method of any of the Java Beans, i.e. \texttt{Sample}.
\end{itemize}
\end{itemize}
while the following methods are generally implemented as well
\begin{itemize}
\item \texttt{public Widget[] createEditWidget(final MObjectDTO obj, final String id)}
\begin{itemize}
\item This method is very similar to \texttt{createDisplayWidget} however
instead it is used when adding/editing objects as opposed to viewing them.  In
the case of the \texttt{TextAttribute} this method would return a GWT
\texttt{TextBox}.
\end{itemize}
\item \texttt{protected Object get(final Widget editWidget)}
\begin{itemize}
\item As mentioned before when the \texttt{set} method is called the second
parameter is the value to set, well the \texttt{get} method is responsible
for getting this value from the \texttt{Widget} that is being edited.  For
example with the \texttt{TextAttribute} the \texttt{get} method would be called
with the \texttt{TextBox} passed in as the editWidget.  Then the method 
proceeds to extract the text from the \texttt{TextBox} and returns it.  In more
advanced attributes usually editWidget is never used and the attribute itself
keeps track of its value through alternate means.
\end{itemize}
\end{itemize}
More advanced attributes have more methods take a look at the \texttt{TreeAttribute} if you want to see them.
\subsection{The Constraints}
The constraints are for validating the data that is contained within the 
attribute.  For example the constraint would be responsible for making sure
that the user entered an integer in a whole number only field.  There are more
advanced instances than that, like verifying that the user chooses an element
is in a predefined list.  In order to explain constraints better I will use the
\texttt{StringConstraint} in the package \texttt{edu\ .rpi\ .metpetdb\ .client\
.model\ .validation}
\footnote{It is located in the mpdb-common project}
\subsubsection{Creating a Constraint}
Constraints are easier to create than attributes in the sense that they are not
required to extend any methods.  However to make the constraint actually do
something useful some methods are helpful to extend.  Before the methods
are explained it is important to note that the each constraint needs to extend
a \texttt{PropertyConstraint}, which by default verifies only that required
attributes have non null values.
\begin{itemize}
\item \texttt{public void validateValue(final Object value) throws 
ValidationException}
\begin{itemize}
\item This method is responsible for validating the passed in value.  If the
value fails validation this method should throw an instance of a
\texttt{ValidationException}.  In the \texttt{StringConstraint} the purpose
of \texttt{validateValue} is to verify that the \texttt{String} meets the
requirements of minimum length and maximum length
\footnote{It also verifies that the \texttt{String} is not null by using the superclass method \texttt{validateValue}}
\footnote{You may be wondering where these minimum and maximum length values 
come from, well so do I.  Actually these values are obtained from the server
and is out of scope of this document.}
.
\end{itemize}
\end{itemize}
\subsection{ObjectEditorPanel Who?}
As mentioned before all of the attributes are layed out on an \texttt{ObjectEditorPanel},
which is an extension of a \texttt{DetailsPanel} with a few features including
\begin{itemize}
\item Default edit,cancel,save, and delete buttons
\item Handles when the current user changes (to update the UI)
\item Handles events like loading, saving, and deleting
\item Has callbacks for the event completions above
\end{itemize}
This allows for easy creation of pages that need to edit objects.  However there are a few
things that need to be implemented specifically for each newly created object.  They are
\begin{itemize}
\item \texttt{protected void loadBean(final AsyncCallback ac)}
\begin{itemize}
\item Within this method should be the service call that is responsible for
loading the bean from the server.  Usually it is something like
\texttt{MpDb.sample\_svc.details(...)}.  This method is \textbf{required}.
\end{itemize}
\item \texttt{protected void saveBean(final AsyncCallback ac)}
\begin{itemize}
\item Similar to the \texttt{loadBean} method this method usually contains a service call
that saves the bean, i.e. \texttt{MpDb.sample\_svc.saveSample(...)}.  This method is 
\textbf{not required}, however, an attempt to save will result in an exception.
\end{itemize}
\item \texttt{protected void deleteBean(final AsyncCallback ac)}
\begin{itemize}
\item Again similar to \texttt{loadBean}, except it is responsible for deleting a bean, the
service call is usually \texttt{MpDb.sample\_svc.delete(...)}.  This method is \textbf{required}.
\end{itemize}
\item \texttt{protected boolean canEdit()}
\begin{itemize}
\item This method just returns whether the current user is allowed to edit this bean.
An example where this is used is that only the owner of a \texttt{Sample} is allowed to 
edit it, so this method \textit{only} returns true when the current user is the owner.
This method is \textbf{not required}, however, it always returns false if not implemented.
\end{itemize}
\end{itemize}
\subsection{Where the Action Happens: DetailsPanel}
The last part of this section describes the majority of where the work of laying out the UI
occurs that is in the class \texttt{DetailsPanel} located in the package 
\texttt{edu\ .rpi\ .metpetdb\ .client\ .ui\ .input}.
A summary of what the \texttt{DetailsPanel} does is as follows
\begin{enumerate}
\item Makes a \texttt{fieldset} and a \texttt{table}
\item For each \texttt{GenericAttribute} it receives it creates
a new row in the table
\item When \texttt{show} is called it calls \texttt{createDisplayWidget}
on each \texttt{GenericAttribute} and adds that widget to the appropriate row
\item When \texttt{edit} is called it calls \texttt{createEditWidget} on each
\texttt{GenericAttribute} and adds that widget to the appropriate row
\item Lastly when the object is done being edited/added the \texttt{validateEdit} 
method is invoked, which validates each \texttt{GenericAttribute} according to its
constraint
\end{enumerate}
\subsubsection{Creating the Table and Rows}
Within the \texttt{init} method the \texttt{fieldset}, \texttt{table}, and rows are
created.  The creation of the \texttt{fieldset} and \texttt{table} is a simple process
of adding them to the \texttt{DOM}.  Next it iterates over each \texttt{GenericAttribute}
and creates a new instance of a \texttt{DetailsPanelRow} which is a data structure that holds
information about the newly created table row.  It also creates a \texttt{DetailsPanelEntry}
for each \texttt{GenericAttribute} which holds more information about the table row.  It is
necessary to have the \texttt{DetailsPanelEntry} because a \texttt{GenericAttribute} can contain
more than one \texttt{DetailsPanelRow}.  The last step of creating the \texttt{table} and 
the rows is to add an actions to the panel.  Actions are usually buttons, in the case of the
\texttt{ObjectEditorPanel} the actions would be the edit, save, cancel, and delete buttons.
\subsubsection{The show Method}
TODO
\subsubsection{The edit Method}
TODO
\subsubsection{Validation}
TODO
\end{document}
